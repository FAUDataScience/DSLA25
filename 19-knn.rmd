---
title: "19 - knn"
author: "Lanning"
date: "March 21, 2019"
output: html_document
---

```{r}
knitr::opts_chunk$set(echo = TRUE, warn = FALSE, message = FALSE) # defaults for all chunks after this one
library(tidyverse)
library(ggplot2)
library(Ecdat) 
library (class) # for knn
library(caret) # confusion matrix
library(magrittr) # allows bidirectional pipe for updating file easily %<>% 
```

# Another approach to classification: k-nearest neighbor

Our real-life social predictions are often guided not by induction or the (optimized) combination of a set of predictor variables.  Rather, we often reason by analogy - we might think, for example, that *I won't go out with Fred because he reminds me of Larry, and Larry was kind of a jerk.*  

If regression analysis is an approach to prediction based in our set of variables, *k-nearest neighbor* analysis instead makes predictions based on observations.  

Formally, as described in the documentation for the knn package,
> For each row of the test set, the k nearest (in Euclidean distance) training set vectors are found, and the classification is decided by majority vote, with ties broken at random. (ref).

In the simplest form of this analysis, we find the nearest thing to a "doppelganger" (a look-alike or near double) for a given observation.  So, in the affairs data, if a person is most like someone else in the dataset who has had an affair, we predict an affair, else not.

## Application: The Fair data

Begin by loading the affairs data from last time.  Using the same seed (33458) means that the same set of training and test cases will be extracted as in the prior analysis

```{r}
data(Fair)
# one change here: Note the bidirectional pipe to simplify code
# use only when you are sure that your file update is ok
Fair %<>% # <- Fair %>% 
    mutate(affairYN =
# nbaffairs is set up as a factor
# to allow confusionmatrix to run
               as.factor(ifelse(nbaffairs > 0,1,0))) %>%
# unlike the lm and glm commands, knn will not automatically create our dummy # variables for us. so we need to do this manually.
    mutate(sexMale = ifelse(sex == "female", 0, 1)) %>% 
    mutate(childyes = ifelse(child == "no", 0, 1)) %>% 
    select(-(c(sex,child,nbaffairs)))

set.seed(33458)
n <- nrow(Fair)
trainIndex <- sample(1:n, size = round(0.6*n), replace = FALSE)
# create training and test samples
trainFair <- Fair[trainIndex ,]
testFair <- Fair[-trainIndex ,]
```

To run a k-nearest neighbor analysis, we need three inputs: our predictors in the training data, our predictors in the test data, and our outcome/classes in the training data.

Here, as in the regression analysis in the last chapter, we can generate a confusion matrix to assess the accuracy of prediction:

```{r}
set.seed(33458)
trainPredictors <- trainFair %>%
    select(-affairYN)
testPredictors <- testFair %>%
    select(-affairYN)
knnAffair <- knn(trainPredictors, # training data
             testPredictors, # test data
             trainFair$affairYN, # class
             1 # number of neighbors
             )
b<-confusionMatrix(knnAffair, testFair$affairYN)
b
b[["overall"]][["Accuracy"]]
```

## From 1 doppelganger to many

In the above code, we used a k-nearest neighbor analysis based on a single 'neighbor' (k = 1). Can we improve prediction by considering more than 1 neighbor? 

### The Bayesian classifier

Lisa is a doctor whose patients often have post-surgical pain. Their suffering is real, but effective pain medications such as OxyContin have a high likelihood of leading to abuse and addiction.  She has two bits of information about a patient, his or her age (say that we have this in ten levels, corresponding to decades of age, so that the first level is "under 20" and that the last level is "over 100"), and his or her self-report of pain, also on a 10 point scale. 

Assume that Lisa wants to prescribe the medication to all patients who would not abuse it, and not prescribe the medication to anyone who would.

Assume that Lisa knew the entire matrix of conditional probabilities, 

> P (addiction | "age < 20" & "pain = 1") = .34
>
> P (addiction | "age < 20" & "pain = 2") = .26
>
> ... P (addiction | "age > 100" & "pain = 10") = .09

In this case she would prescribe the drug for every case where the conditional probability was greater than .5, and never otherwise.  This is called the **Bayesian classifier**, and if we have the entire matrix of conditional probabilities we could do no better. 

In real world problems, we are typically dealing with many predictors, and we don't have the full matrix of conditional probabilities. But this two predictor case "sets up" the illustration drawn from [@james2013introduction].

![Figure 10.1: Comparing two values of k (From @jamesintroduction)](C:\Users\lanning\Dropbox\0DataSciLibArts\knnTwovaluesfromJames2013.PNG)

In the figure above, assume that the horizontal and vertical axes correspond to scores on the two predictors (age and pain). The orange and blue colored dots correspond to cases of abuse and non-abuse in the training data. The dashed line is the Bayesian classifier.  The solid line is the k-nn decision boundary, which distinguishes the regions in which we will predict abuse and non abuse in the test data.  We see that when k is small (a single neighbor), prediction is flexible, non-linear, and that as k increases, the boundary differentiating the decision to prescribe and not prescribe becomes more nearly linear. 

But what value of k is optimal?

### Back to the Fair data

To test a range of values, we can first set up our knn analysis as a function (compare this code with the code in the prior section).

```{r}
trainPredictors <- trainFair %>%
    select(-affairYN)
testPredictors <- testFair %>%
    select(-affairYN)
knnFairdata <- function (k) {
    set.seed(33458)
    knnAffair <- knn(trainPredictors, # training data
                 testPredictors, # test data
                 trainFair$affairYN, # class
                 k # number of neighbors
                 )
    b<-confusionMatrix(knnAffair, testFair$affairYN)
    b[["overall"]][["Accuracy"]]
}
```


We run the function on k = 1 and k = 2 to test it:
```{r}
knnFairdata(1)
knnFairdata(2)
```
Now we can apply it to as many as 100 values of k, using the purrr::map command:

```{r}
kAccuracy <- (map(1:100,knnFairdata)) %>% # map the knnFunction onto numbers 1-100
    unlist() %>% # map generates a list, so we will pull these out into a vector
    as_tibble() %>%  # then a tibble so we can do a quick plot
    rename(Accuracy=value) %>% 
    mutate (k = seq_along(Accuracy))
```

We can graph this, using the syntax from the beginning of the class:
```{r}
kAccuracy %>% 
    ggplot(aes(k, Accuracy)) +#%>% 
    geom_point() +
    ggtitle("Overall accuracy for varying levels of k")
# This pulls out the maximum accuracy, and the value of k for which it occurs:
(ka <- which.max(kAccuracy$Accuracy))
(kb <- max(kAccuracy$Accuracy))
```

## Avoiding capitalization on chance (again)

In these data, with this split of training and test (and this initial seed) the maximum predictability occurs at k = `r ka`, with an overall accuracy of `r kb`. 

Would this hold if we used a different random split? Remember, here, we have tested not one model, but 100 of them, then chosen the best one.  The peak in the curve at `r ka` may well be due to chance characteristics of the test data.  

We could address this empirically using one of several techniques. One approach is to have a third independent sample on which to test the accuracy of prediction at k = `r ka`. This would require the separate validation sample that was introduced in the last chapter.

In the following block, I resplit the Fair data, using proportions of 60%, 30%, 10%.  These values are likely not optimal given the (relatively small) size of the Fair data, but will work to illustrate the approach: 
```{r}
set.seed(33458)
threeWaySplit <- sample(1:3, size=nrow(Fair),
                        prob=c(0.6,0.3,0.1),
                        replace = TRUE)
trainFair2 <- Fair[threeWaySplit==1,]
testFair2 <- Fair[threeWaySplit==2,]
validFair2 <- Fair[threeWaySplit==3,]
```

I tweak my function here to use the new data, then run it 100 times as before.
```{r}
trainPredictors <- trainFair2 %>%
    select(-affairYN)
testPredictors <- testFair2 %>%
    select(-affairYN)
knnFairdata2 <- function (k) {
    set.seed(33458)
    knnAffair <- knn(trainPredictors, # training data
             testPredictors, # test data
             trainFair2$affairYN, # class
             k # number of neighbors
             )
    b<-confusionMatrix(knnAffair, testFair2$affairYN)
    b[["overall"]][["Accuracy"]]
}
kAccuracy <- (map(1:100,knnFairdata2)) %>% # map the knnFunction onto numbers 1-100
    unlist() %>% # map generates a list, so we will pull these out into a vector
    as_tibble() %>%  # then a tibble so we can do a quick plot
    rename(Accuracy=value) %>% 
    mutate (k = seq_along(Accuracy))
(ka2 <- which.max(kAccuracy$Accuracy))
(kb2 <- max(kAccuracy$Accuracy))
```

So here, on the (contaminated) test data, the maximum predictability occurs at k = `r ka2`, with an overall accuracy of `r kb2`.  We apply this back to the validation data by pulling the knn code out of the function, and running it just once against the validation data:

```{r}
knnAffair <- knn(trainFair2[,-7], # training data
             validFair2[,-7], # VALIDATION data
             trainFair2$affairYN, # class
             ka2 # number of neighbors
             )
b<-confusionMatrix(knnAffair, validFair2$affairYN)
(kb3 <- b[["overall"]][["Accuracy"]])
```

We see that the overall predictability using the k-nearest neighbor analysis on the clean validation data, is now `r kb3`.  

You might note that in our two splits of the Fair data - the two-way split of 60% Training and 40% Test, and the three-way split of 60% Training, 30% Test, 10% Validation, we got two different solutions to the question of the 'optimal k' (i.e., `r ka` and `r ka2`). With larger sample sizes, these values would be more stable.  

## The multinomial case

A final comment on the k-nearest neighbors approach: You can extend this to classification problems in which we are predicting not just a dichotomous outcome, but a multinomial one - such as a personality type or college concentration.




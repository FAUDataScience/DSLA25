---
title: "14 - strings, factors, dates, and times"
author: "Lanning"
date: "`r Sys.Date()`"
output: html_document
---
# strings, factors, dates, and times

This chapter discusses some of the types of data other than numeric and logical, in particular strings, factors, and dates/times. 

In this chapter, as in the last few, I refer primarily to three of the chapters in R4DS. Consider these notes supplementary.

## strings

Strings are sets of characters which may include "123" as well as "why \*DID\* the chicken cross the road?" Snippets of text are the most interesting type of string.

String manipulation gets complicated when, for example, it includes characters that R usually interprets as code - such as commas, quotes, and slashes. See the section on string basics (14.2) for how to "escape" these characters, for example, how to treat a hashtag (#) as just a character as opposed to the beginning of a comment.

Regular expressions (regex) are a formal type of code which constitute the most basic part of searching within strings. Regex are not unique to R, but are shared with other languages as well.  The density of regex statements can make them appear (be) challenging, fortunately, there are many resources available to help you get a handle on these, including simple google searches.  

> Use the cheat sheet at https://regexr.com/ to work through (some of) the exercises in chapter 14.3.

Section 14.4 describes the stringr package, which is a relatively accessible and versatile set of tools for working with strings in R. You are likely to use many of these, but less likely to use stringi (section 14.7). The tidytext package (https://www.tidytextmining.com/), which is discussed at length in the computational social science course, is a more powerful set of tools for all sorts of problems in formal text analysis.

## factors

Conditions (experimental vs control), categories (male or female), types (scorpio, "hates astrology") and other nominal measures are categorical variables or factors. In the tidyverse, the r package for dealing with this type of measure is *forcats*, one of the core parts of the tidyverse. 

Here's an example of a categorical variable. Why is it set up like this, and what does it do?

```{r factors.0314}
library(tidyverse)
# Example of a factor
eyes <- factor(x = c("blue", "green",
                     "green", "creepyRed"), 
               levels = c("blue", "brown",
                          "green"))
eyes
```

In base R, string variables ("donut", "anti-Brexit", and "yellow") are generally treated as factors by default.  In the tidyverse, string variables are treated as strings until they are explicitly declared as factors.  

The syntax for working with factors-as-categories is given in Chapter 15 of R4DS. I will not duplicate that here, but I will point out that factors are represented internally in R as numbers, and converting factors to other data types can occasionally lead to nasty surprises. Sections 15.4 and 15.5 describe how factors can be cleanly reordered and modified. 

In the babynames data, baby's gender is a categorical variable, which is treated (because tidyverse) as a character or string.  Here, we split the set of names into two separate tibbles - one for baby boys and one for baby girls. This is one way to set up the problem to look at androgynous names.

```{r echo=TRUE, results="hide", message=FALSE}
library(tidyverse)
library(babynames)
maleNames <- babynames %>% 
    filter(sex == "M") %>% 
    rename(nBoy = n, propBoy = prop)
femaleNames <- babynames %>%
    filter(sex == "F") %>% 
    rename(nGirl = n, propGirl = prop)
androNames <- maleNames %>% 
    inner_join(., femaleNames, by = c("name", "year"))
```

We can use forcats with the babynames data, for example, to lump together rare names, like this. 
```{r echo=TRUE, results="hide", message=FALSE, warning=FALSE}
allNames <-
babynames %>% 
    group_by(sex) %>% 
    mutate(bigNames = fct_lump(name, n = 10))
```

## dates

The challenges of combining time-demarcated data (Chapter 16) are significant.  For dates, a variety of different formats (3-April, October 23, 1943, 10/12/92) must be made sense of. Sometimes we are concerned with durations (how many days, etc.); on other occasions, we are concerned with characteristics of particular dates (as in figuring out the day of the week on which you were born). And don't forget about leap years.

In R, the *lubridate* package (a non-core part of the tidyverse, i.e., one that you must load separately) helps to handle dates and times smoothly. It anticipates many of the problems we might encounter in extracting date and time information from strings.  Lubridate generally works well to simplify files with dates and times, and can be used to help in data munging. For example, in my analyses of the Corona data, dates and times were reported in four different ways. The code below decodes these transparently and combines them into a common date/time format . 

> 2/3/20 6 PM
>
> 2/3/20 18:00
>
> 2/3/20 18:00:00
>
> 2020-02-03 18:00:00

```{r echo=TRUE, eval = FALSE}
# not run
coronaData2 <- coronaData %>% mutate
	(`FixedDate = 
           parse_date_time(`Last Update`,
                           c('mdy hp','mdy HM',
                             'mdy HMS','ymd HMS'))) 
```

## times

Working with temporal data is often challenging. The existence of, for example, 12 versus 24 hour clocks, time zones, and daylight savings, can make a simple question about duration quite challenging. 

> Imagine that Fred was born in Singapore at the exact moment of Y2K. He now lives in NYC. How many hours has he been alive as of right now? How would you solve this?




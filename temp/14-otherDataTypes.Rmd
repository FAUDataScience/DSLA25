---
title: "14 - strings, factors, dates, and times"
author: "Lanning"
date: "`r Sys.Date()`"
output: html_document
---
(Google verification fails)
# strings, factors, dates, and times

## status 60% {-}

ultimately, should be split into two or more separate chapters. the section on strings/text is probably farthest along. The Singapore example at the end of the chapter should be solved here.

---



This chapter discusses some of the types of data other than numeric and logical, in particular strings, factors, and dates/times. 

In this chapter, as in the last few, I refer primarily to three of the chapters in R4DS. Consider these notes supplementary.

## strings

Strings are sets of characters which may include "123" as well as "why \*DID\* the chicken cross the road?" Snippets of text are the most interesting type of string.

String manipulation gets complicated when, for example, it includes characters that R usually interprets as code - such as commas, quotes, and slashes. See the section on string basics (14.2) for how to "escape" these characters, for example, how to treat a hashtag (#) as just a character as opposed to the beginning of a comment.

Regular expressions (regex) are a formal type of code which constitute the most basic part of searching within strings. Regex are not unique to R, but are shared with other languages as well.  The density of regex statements can make them appear challenging, fortunately, there are many resources available to help you get a handle on these, including simple google searches.  

> Use the cheat sheet at https://regexr.com/ to work through (some of) the exercises in chapter 14.3.

Section 14.4 describes the stringr package, which is a relatively accessible and versatile set of tools for working with strings in R. You are likely to use many of these, but less likely to use stringi (section 14.7). The tidytext package (https://www.tidytextmining.com/), which will be discussed at length in the computational social science course, is a more powerful set of tools for all sorts of problems in formal text analysis.

## factors

Conditions (experimental vs control), categories (male or female), types (scorpio, "hates astrology") and other nominal measures are categorical variables or factors. In the tidyverse, the r package for dealing with this type of measure is *forcats*, one of the core parts of the tidyverse. 

Here's an example of a categorical variable. Why is it set up like this, and what does it do?

```{r factors.0314}
#install.packages("fansi")
#library(fansi)
library(tidyverse)
library(lubridate)
library(googledrive)
library(googlesheets4)
# Example of a factor
eyes <- factor(x = c("blue", "green",
                     "green", "creepyRed"), 
               levels = c("blue", "brown",
                          "green"))
eyes
```

In base R, string variables ("donut", "anti-Brexit", and "yellow") are generally treated as factors by default.  In the tidyverse, string variables are treated as strings until they are explicitly declared as factors.  

The syntax for working with factors-as-categories is given in Chapter 15 of R4DS. I will not duplicate that here, but I will point out that factors are represented internally in R as numbers, and converting factors to other data types can occasionally lead to nasty surprises. Sections 15.4 and 15.5 describe how factors can be cleanly reordered and modified. 

In the babynames data, baby's gender is a categorical variable, which is treated (because tidyverse) as a character or string.  Here, we split the set of names into two separate tibbles - one for baby boys and one for baby girls. This allows us to set up the problem to look at androgynous names.

```{r echo=TRUE, results="hide", message=FALSE}
library(tidyverse)
library(babynames)
maleNames <- babynames %>% 
    filter(sex == "M") %>% 
    rename(nBoy = n, propBoy = prop)
femaleNames <- babynames %>%
    filter(sex == "F") %>% 
    rename(nGirl = n, propGirl = prop)
androNames <- maleNames %>% 
    inner_join(., femaleNames, by = c("name", "year"))
```

We can use forcats with the babynames data, for example, to lump together rare names, like this. 
```{r echo=TRUE, results="hide", message=FALSE, warning=FALSE}
allNames <-
babynames %>% 
    group_by(sex) %>% 
    mutate(bigNames = fct_lump(name, n = 10))
```

## dates

The challenges of combining time-demarcated data (Chapter 16) are significant.  For dates, a variety of different formats (3-April, October 23, 1943, 10/12/92) must be made sense of. Sometimes we are concerned with durations (how many days, etc.); on other occasions, we are concerned with characteristics of particular dates (as in figuring out the day of the week on which you were born). And don't forget about leap years.

Here's a simple use of *lubridate* which allows ordering of months across years (i.e., it puts December 2018 before January 2019). I apply it to a new data set fakeSpinData, which is pulled from a Google sheet.
(For 2020, the Google sheet - now Googlesheet4 - interface is buggy.  )

```{r echo=TRUE, message=FALSE}

# drive_auth()
# sheets_auth(token = drive_token())
# library(googlesheets) is obsolete
library(kableExtra)
# https://github.com/tidyverse/googledrive/issues/279 on 1/11/20
# gFiles <- drive_ls(pattern="pin")
# spinData <- sheets_get("fakeSpinData")
# spinData <- spinData %>% 
# set up old Date field as a lubridate-readable date
# note that the new field is date rather than Date - dumb names
#    mutate(date = mdy(Date)) %>% 
# extract month and year
#    mutate(month = month(date,label = TRUE)) %>% 
#    mutate(year = year(date))

# kable(spinData %>% 
# make an ordered cool table
#    group_by(year, month) %>% 
#    summarize(sum(calories), sum(time))) %>% 
#    kable_styling(bootstrap_options = c(
#        "striped", "hover", "condensed"),
#        full_width = FALSE, position = "left")
```


## times

In the table above, we are given time in seconds. It would be easy to convert this to time in minutes or hours.  But working with temporal data is often more challenging than this. The existence of, for example, 12 versus 24 hour clocks, time zones, and daylight savings, can make a simple question about duration quite challenging. 

> Imagine that Fred was born in Singapore at the exact moment of Y2K. He now lives in NYC. How many hours has he been alive as of March 15, 2019? How would you solve this?

in R, the *lubridate* package (a non-core part of the tidyverse, i.e., one that you must load separately) helps to handle dates and times smoothly. It anticipates many of the problems we might encounter in extracting date and time information from strings.  


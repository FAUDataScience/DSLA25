[
["loops-functions-and-beyond.html", "16 loops, functions, and beyond 16.1 loops 16.2 from loop to apply to purrr::map 16.3 some examples of functions 16.4 how many bottles of what?", " 16 loops, functions, and beyond In one of the most important contemporary theoretical models of intelligence, (Sternberg 1999) has argued that the ability to automatize, that is, to work efficiently on repeated or habitual tasks, is a key component of intelligent behavior. Solving habitual problems efficiently - whether it is making a cup of coffee, honing to the shortest path to compete a shopping list in a supermarket or finish a series of errands across town - allows us to focus our limited resources on other challenging tasks. In programming, loops and functions are essential tools for making repetitive tasks simple. Simplifying your code is one of the more intellectually satisfying aspects of working in R or in any programming language. In R, loops are supplemented by additional tools for simplifying and avoiding repetition in code, including the ‘apply’ family and the map function in purrr. Functions (and, beyond this, custom libraries) can further streamline your work. 16.1 loops Consider the task of printing out a series of numbers. Here’s a simple example of how this could be done in a loop in R. It prints numbers between 1995 and 1998 (inclusive). knitr::opts_chunk$set(message = FALSE, warning = FALSE) library(kableExtra) library(tidyverse) ## -- Attaching packages ------------------- ## v ggplot2 3.3.0 v purrr 0.3.3 ## v tibble 3.0.0 v dplyr 0.8.5 ## v tidyr 1.0.2 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts --- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::group_rows() masks kableExtra::group_rows() ## x dplyr::lag() masks stats::lag() library(babynames) for (i in 1995:1998) { # i is an index code print(i) # print the ith value in the sequence } # go to the next one until the range is complete ## [1] 1995 ## [1] 1996 ## [1] 1997 ## [1] 1998 Let’s expand on this a little, connecting back to the babynames data. This will print counts of the number of babies for each year in GenerationZ, which includes years from 1995-2015. genZ &lt;- (1995:2015) # this reduces the (big) babynames to a simple file of years and counts babyCounts &lt;- babynames %&gt;% group_by(year) %&gt;% filter(year %in% genZ) %&gt;% summarize(nbabies = sum(n)) # and this uses a for loop to print each row in turn for (i in (1:nrow(babyCounts))) { # filename[i,j] == ith row and jth column print(paste((babyCounts[i,1]), babyCounts[i,2])) } ## [1] &quot;1995 3661351&quot; ## [1] &quot;1996 3646362&quot; ## [1] &quot;1997 3624799&quot; ## [1] &quot;1998 3677107&quot; ## [1] &quot;1999 3692537&quot; ## [1] &quot;2000 3778079&quot; ## [1] &quot;2001 3741451&quot; ## [1] &quot;2002 3736042&quot; ## [1] &quot;2003 3799971&quot; ## [1] &quot;2004 3818361&quot; ## [1] &quot;2005 3842004&quot; ## [1] &quot;2006 3952932&quot; ## [1] &quot;2007 3994007&quot; ## [1] &quot;2008 3926358&quot; ## [1] &quot;2009 3815638&quot; ## [1] &quot;2010 3690700&quot; ## [1] &quot;2011 3651914&quot; ## [1] &quot;2012 3650462&quot; ## [1] &quot;2013 3637310&quot; ## [1] &quot;2014 3696311&quot; ## [1] &quot;2015 3688687&quot; The syntax of loops, including where to put parentheses in index statements, can be tricky. Expect to refer to Google and StackExchange often in order to get your code running. Another good source is Chapter 21 of R4DS. There, Wickham goes in to additional detail, including a description of seq_along(df) as a tool for creating an index corresponding to 1:ncol(df). Here’s an example with the diamonds dataset: diamonds2 &lt;- diamonds %&gt;% select_if(., is.numeric) # for (i in (1:ncol(diamonds2))) { for (i in seq_along(diamonds2)) { print(paste(names(diamonds2[i]), round(mean(diamonds2[[i]]),2))) } ## [1] &quot;carat 0.8&quot; ## [1] &quot;depth 61.75&quot; ## [1] &quot;table 57.46&quot; ## [1] &quot;price 3932.8&quot; ## [1] &quot;x 5.73&quot; ## [1] &quot;y 5.73&quot; ## [1] &quot;z 3.54&quot; Chapter 21 of R4DS also considers some extensions to related problems such as loops of indefinite length, which can often be addressed using the ‘while’ command. 16.2 from loop to apply to purrr::map Understanding for loops is fundamental in programming, but in R they should often be sidestepped. If the order of iteration isn’t important (if, for example, it doesn’t matter which of the diamonds variables we take the mean of first), then using one of the measures from the apply family can generally be used to make your code simpler and more efficient. The logic is that one takes a dataframe (df or tibble), then applies a function to its rows or columns: # apply the function (mean) to the columns(2) of the df diamonds2 %&gt;% apply(2,mean) ## carat depth table price x y ## 0.7979397 61.7494049 57.4571839 3932.7997219 5.7311572 5.7345260 ## z ## 3.5387338 # simply apply - guesses that you are looking for col. means diamonds2 %&gt;% sapply(mean) ## carat depth table price x y ## 0.7979397 61.7494049 57.4571839 3932.7997219 5.7311572 5.7345260 ## z ## 3.5387338 The many variants of the apply family, including lapply [list apply] and tapply [table apply] as well as sapply, each have their own uses and can be quite efficient but, again, can be syntactically challenging. In the evolving tidyverse, the map family of commands is supplementing if not supplanting apply; these commands (part of the purrr package in the core tidyverse) may prove to be more convenient and clear. For example, the map_df function will apply a function and return a dataframe (tibble), which can be handy for further analysis. b &lt;-diamonds2 %&gt;% map_df(mean) b ## # A tibble: 1 x 7 ## carat depth table price x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.798 61.7 57.5 3933. 5.73 5.73 3.54 16.3 some examples of functions If you repeat a series of lines of code several times in your program, it is often best to wrap this into a function. The first example is from a preregistered study I recently started of language and politics. For the preregistration, I ran analyses using simulated data, both to increase the likelihood that the code will run without error on real data and to help anticipate the analyses which are to be run on ‘real’ data. I began by getting a real body of text from the net and scrambling it, then constructing fake ‘Republican’ and ‘Democratic’ texts from this. Here, I illustrate this by constructing 50 sample documents, each consisting of between 5 and 20 words. The project is given in four steps: 16.3.1 preliminaries Here is the preliminary stuff, where I pull the data off the net and initialize the variables library(tidyverse) sampledata &lt;- read_csv(url( # &quot;https://www.crowdflower.com/wp-content/uploads/2016/03/sentiment-words-DFE-785960.csv&quot;)) &quot;https://raw.githubusercontent.com/totalgood/hope/master/data/corpora/sentiment-words-DFE-785960.csv&quot;)) # pulls off four words sampledata &lt;- sampledata[22:25] %&gt;% na.omit() ndocs &lt;- 50 minDocLength &lt;- 5 maxDocLength &lt;- 20 doc &lt;- vector(mode = &quot;character&quot;, length = ndocs) 16.3.2 the function Here’s the simple function which pulls a random word out of the matrix of sampledata. set.seed(33458) # a random seed is used to allow reproducible results getword &lt;- function() { rowid &lt;- sample(1:nrow(sampledata), 1) colid &lt;- sample(1:ncol(sampledata), 1) word &lt;- sampledata[rowid,colid] word } 16.3.3 applying the function The function is applied, first, to extract one word, then, in successive loops, to build up one phrase and then many. # combine words into docs # establish length of first phrase docLength &lt;- sample(minDocLength:maxDocLength,1) # initialize with one word sampleCorpus &lt;- getword() # loop to build up first phrase for (i in 1:docLength) { addWord &lt;- getword() sampleCorpus &lt;- paste(sampleCorpus, addWord) } #add additional simulated documents for (j in 2:ndocs) { docLength &lt;- sample(minDocLength:maxDocLength,1) newdoc &lt;- getword() for (i in 1:docLength - 1) { addWord &lt;- getword() newdoc &lt;- paste(newdoc, addWord) } sampleCorpus &lt;- rbind(newdoc,sampleCorpus) } Finally, the results are combined with a vector of alternating labels of ‘Dem’ and ‘Rep’: row.names(sampleCorpus) &lt;- NULL evenOdd &lt;- rep(c(&quot;Dem&quot;,&quot;Rep&quot;),length.out = nrow(sampleCorpus)) workingCorpus &lt;- as.tibble(cbind(evenOdd,sampleCorpus)) head(workingCorpus,5) ## # A tibble: 5 x 2 ## evenOdd V2 ## &lt;chr&gt; &lt;chr&gt; ## 1 Dem wild at heart nobody loves me lost art miss the sun need a doctor kin~ ## 2 Rep great player awfully nice back hurts not paying pretty rubbish found ~ ## 3 Dem yahooo make no promises horrible daughter ew crazy evening fit ## 4 Rep can&#39;t sleep lazy afternoon sucks #fedup great shame positive break fa~ ## 5 Dem problems nice funniest hurt not necessarily sad nose eat no problem d~ 16.4 how many bottles of what? To put the fun back into function, here’s a solution to the “99 bottles of beer” function described in r4DS 21.2.1. Study the code. Ask or answer a question about it in class or on Slack. beerSong &lt;- function(liquid = &quot;beer&quot;, count = 99, surface = &quot;wall&quot;) { songtext &lt;- &quot;&quot; for (i in (count:1)) { thisLine = (paste0(i, &quot; bottles of &quot;, liquid, &quot; on the &quot;, surface, &quot;, you take one down and pass it around,\\n&quot;)) songtext = c(songtext, thisLine) } songtext = c(songtext, (paste0(&quot;no more bottles of &quot;, liquid,&quot; on the &quot;, surface,&quot;...&quot;))) cat(songtext) # cat prints without line numbers } #beerSong() And here are solutions proposed by some of your classmates. How do they differ from each other, and from the solution given above? beersng &lt;- function(n) { if (n == 1) { cat(&quot;\\n&quot;,n,&quot; bottle of beer on the wall, &quot;,n, &quot; bottles of beer.\\nTake one down and pass it around,&quot;, &quot; no more bottles of beer on the wall.\\n&quot;, sep = &quot;&quot;) cat(&quot;\\nNo more bottles of beer on the wall, no more bottles of beer.\\n&quot;, &quot;Go to the store and buy some more, 99 bottles of beer on the wall.\\n&quot;, sep=&quot;&quot;) } else { cat(&quot;\\n&quot;,n,&quot; bottles of beer on the wall, &quot;,n, &quot; bottles of beer.\\nTake one down and pass it around, &quot;, n-1, &quot; more bottles of beer on the wall.\\n&quot;, sep=&quot;&quot;) return(beersng(n-1)) } } #beersng(99) moreBeer &lt;- function () { for (i in 0:100){ starting_number &lt;- 100 if (starting_number - i == 0) { print(&quot;No more bottles of beer on the wall, no more bottles of beer, Go to the store and buy some more, 99 bottles of beer on the wall.&quot;) break } print(paste(starting_number - i, &quot;bottles of beer on the wall&quot;, &quot;Take one down and pass it around,&quot;, starting_number - i - 1, &quot;bottles of beer on the wall.&quot;)) } } # moreBeer() song &lt;- function(bottlesofbeer){ for(i in bottlesofbeer:1){ cat(bottlesofbeer,&quot; bottles of beer on the wall \\n&quot;, bottlesofbeer,&quot; bottles of beer \\nTake one down, pass it around \\n&quot;, bottlesofbeer-1, &quot; bottles of beer on the wall \\n&quot;,&quot; \\n&quot;) bottlesofbeer = bottlesofbeer - 1 } } #song(99) Which code is ‘best’? Good code is clear, but it is also efficient. We probably shouldn’t expect much in the way of differences between these functions in terms of speed (as each includes 99 iterations of a simple print command), but here’s a simple way to compare. Note that I’ve used the “sink” command to write my output to files rather than consoles: start_time &lt;- Sys.time() sink (file = &quot;f1.txt&quot;) beerSong(&quot;beer&quot;,99) sink() end_time &lt;- Sys.time() beerSongtime &lt;- end_time - start_time start_time &lt;- Sys.time() sink (file = &quot;f2.txt&quot;) beersng(99) sink() end_time &lt;- Sys.time() beersngtime &lt;- end_time - start_time start_time &lt;- Sys.time() sink (file = &quot;f3.txt&quot;) song(99) sink() end_time &lt;- Sys.time() songtime &lt;- end_time - start_time start_time &lt;- Sys.time() sink (file = &quot;f4.txt&quot;) moreBeer() sink() end_time &lt;- Sys.time() moreBeertime &lt;- end_time - start_time Here is the first line of output from each function, together with table showing the elapsed times: readLines(&quot;f1.txt&quot;,1) ## character(0) readLines(&quot;f2.txt&quot;,2) ## character(0) readLines(&quot;f3.txt&quot;,4) ## character(0) readLines(&quot;f4.txt&quot;,1) ## character(0) tibble(functionName = c(&quot;beerSongtime&quot;, &quot;beersngtime&quot;, &quot;songtime&quot;, &quot;moreBeertime&quot;), time = c(beerSongtime,beersngtime, songtime, moreBeertime)) %&gt;% kable(digits = 2) functionName time beerSongtime 0.06 secs beersngtime 0.03 secs songtime 0.04 secs moreBeertime 0.04 secs references "]
]
